# 객체 지향 프로그래밍

### 객체 지향 프로그래밍(OOP)

Object-Oriented Programing

### [ 미리 알아두면 좋을 개념들 ]

- 클래스 : 객체를 만들어 내기 위한 설계도 혹은 틀, 연관되어 있는 변수와 메서드의 집합
- 객체 : 소프트웨어 세계에 구현할 대상, 클래스에 선언된 모양 그대로 생성된 실체, '클래스의 인스턴스'라고도 부른다. 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다. **oop의 관점에서 클래스의 타입으로 선언되었을 때 '객체'라고 부른다.**
- 인스턴스 : 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체, 실체화된 인스턴스는 메모리에 할당된다. **oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 '인스턴스'라고 부른다.** 인스턴스라는 용어는 반드시 클래스와 객체 사이의 관계로 한정지어서 사용할 필요는 없다. **추상적인 개념(또는 명세)과 구체적인 객체 사이의 관계에 초점**을 맞출 경우에 사용한다. 보통 어떤 원본(추상적인 개념)으로부터 '생성된 복제본'을 의미로 이해하면 됨! 

객체 지향 프로그래밍은 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방식이다. 쉽게 말해, 큰 문제를 작게 쪼개는 방식이 아니라 작은 문들을 해결할 수 있는 객체들을 만든 뒤, 이 객체들을 조합해서 큰 문제를 해결하는 Bottom-Up 방식을 지향한다.

### 객체 지향 프로그래밍의 장점

- 코드 재사용 용이 : 남이 만든 클래스를 가져와서 사용할 수 있고, 상속을 통해 확장해서 사용할 수 있다.
- 유지보수가 쉬움 : 절차 지향 프로그래밍에서는 코드를 수정해야 할 때 일일이 찾아 수정해야하는데 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 변수나 메서드로 존재하기 때문에 해당 부분만 수정하면 된다.
- 대형 프로젝트에 적합 : 클래스 단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트에서 업무 분담하기 좋다.

### 객체 지향 프로그래밍의 단점

- 처리 속도가 상대적으로 느림
- 객체가 많으면 용량이 커질 수 있음
- 설계시 많은 시간과 노력이 필요함.

### 객체 지향 프로그래밍의 특징 4가지

#### 1. 추상화

객체의 공통적인 속성과 기능을 추출하여 정의하는 것. 즉, 세부적인 사물들의 공통적인 특징을 파악한 후, 하나의 묶음으로 만들어내는 것

예시 : 칸쵸, 칙촉, 빼빼로, 빈츠, 몽쉘은 모두 '과자'라는 공통점이 있다.

'과자'라는 추상화 집합을 만들고, 이들이 가진 공통적인 특징들(초코 과자, 롯데제과 등)을 만들어 활용하면 된다. 예를 들어, 씨리얼같은 과자도 '과자'라는 집합에 추가될 수 있는데, 이 때 추상화로 구현해두면 다른 코드는 건들지 않고 추가로 만들 부분만 새로 만들어 주면 된다.



### 2. 캡슐화

클래스 안에 서로 연관되어 있는 속성과 기능들을 캡슐로 만들어 데이터를 외부로부터 보호하는 것을 말한다. 캡슐화를 하는 이유는 데이터 보호와 데이터 은닉이라는 2가지 이유가 있는데, 외부로부터 클래스에 정의된 속성과 기능들을 보호하고 내부의 동작을 감추고 외부에서는 필요한 부분만 노출하여 각 객체의 고유성과 책임 영역을 안전하게 지키고자 하는 것이다. 쉽게 말해, 정보 은닉화를 통해 높은 응집도, 낮은 결합도를 유지할 수 있도록 설계하는 것을 말한다.(한 곳에서 변화가 일어나도 다른 곳에 미치는 사이트 이펙트를 최소화시키는 것!) 외부 객체는 객체 내부의 구조를 모르게 하고, 해당 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있도록 하여 의도하지 않은 동작 오류를 방지하고 유지보수 효율을 높일 수 있다.



### 3. 상속

상속은 부모 클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식 클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것이다.

또한 객체지향 프로그래밍에서는 '코드 재사용'을 목적으로 하는 상속 행위는 엄격하게 금한다. 코드를 재사용할 수 있다고 무지성으로 상속을 사용하게 되면, 클래스 간 결합도가 높아져서 유지보수하기에 어렵다. 그래서 일반적인 개념을 구체화하는 상황에서 상속을 사용하는 것이 좋다.



### 4. 다형성

어떤 객체의 속성이나 기능이 맥락에 따라 다른 역할을 수행할 수 있는 성질. 대표적으로 메서드 오버라이딩과 메서드 오버로딩이 있다. 

보통 부모 클래스로부터 상속을 받은 속성에 대해, 물려받은 속성을 재정의 할 수 있는데, 이를 오버라이딩이라 부르고 다형성을 허용하는 것이다. 

코드를 간결하게 해주고, 유연함을 갖추게 된다.

예를 들어, 고양이와 사자.

고양이 클래스에 "울음"이라는 속성이 정의되어 있다고 가정.

사자는 고양이과이기 때문에 사자 클래스는 고양이 클래스를 상속받는다고 하면, 자동으로 "울음"이라는 속성이 추가된다.

하지만 우리는 사자와 고양이의 울음소리가 다르다는 것을 알고 있다. 고양이는 "야옹", 사자는 "크왕"이라고 하면, 사자 클래스의 울음 속성을 재정의 할 수 있다. 이것을 오버라이딩이라 한다.

즉, 사자 클래스는 부모클래스인 고양이 클래스의 "울음" 속성을 상속받았지만, 사자는 고양이와 울음소리가 다르므로 "울음" 속성을 오버라이딩 해서 사자 울음소리에 맞게 재정의 할 수 있다. oop에서는 이러한 다형성을 허용하는 것이다.

다형성을 사용하면 같은 이름의 속성을 유지함으로써, 속성을 사용하기 위한 인터페이스를 유지하고 메서드를 낭비할 필요가 없다. 예를 들어, 고양이와 사자의 울음소리를 호출하기 위해서 각 개체에서 roar() 메서드를 호출하면 됩니다. roarCat() , roarLion() 으로 각각을 정의할 필요가 없다는 것이죠.

출처 

https://velog.io/@haero_kim/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95

https://jeong-pro.tistory.com/95